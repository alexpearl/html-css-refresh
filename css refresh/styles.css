.red-text {
  color: red;
}

h2 {
  font-family: Lobster, monospace;
}

p {
  font-size: 16px;
  font-family: monospace;
}

.thick-green-border {
  border-color: green;
  border-width: 10px;
  border-style: solid;
  border-radius: 50%;
}

.smaller-image {
  width: 100px;
}
.injected-text {
  margin-bottom: -25px;
  text-align: center;
}

.box {
  border-style: solid;
  border-color: black;
  border-width: 5px;
  text-align: center;
}

.yellow-box {
  background-color: yellow;
  padding: 10px;
}

.red-box {
  background-color: crimson;
  color: #fff;
  padding: 20px;
}

.blue-box {
  background-color: blue;
  color: #fff;
  padding: 10px;
}

/* browsers read CSS from top to bottom in order of their declaration. That means that, in the event of a conflict, the browser will use whichever CSS declaration came last. */
/* id overides class  */
/* inline styles take precedence over ids but they're gross lol */
/* use !important, In many situations, you will use CSS libraries. These may accidentally override your own CSS. So when you absolutely need to be sure that an element has specific CSS, you can use !important */
/* To create a CSS variable, you just need to give it a name with two hyphens in front of it and assign it a value like this:
--penguin-skin: gray; */
/* After you create your variable, you can assign its value to other CSS properties by referencing the name you gave it.
background: var(--penguin-skin); can also attach a fallback value var(--penguin-skin, black) */

/* text-align: justify; causes all lines of text except the last line to meet the left and right edges of the line box.

text-align: center; centers the text

text-align: right; right-aligns the text

And text-align: left; (the default) left-aligns the text.

With the strong tag, the browser applies the CSS of font-weight: bold; to the element.
With the u tag, the browser applies the CSS of text-decoration: underline; to the element.
To emphasize text, you can use the em tag. This displays text as italicized, as the browser applies the CSS of font-style: italic; to the element.
s tag, the browser applies the CSS of text-decoration: line-through;
You can use the hr tag to add a horizontal line across the width of its containing element.

The box-shadow property applies one or more shadows to an element.
The box-shadow property takes values for

offset-x (how far to push the shadow horizontally from the element),
offset-y (how far to push the shadow vertically from the element),
blur-radius,
spread-radius and
color, in that order.

The text-transform property in CSS is used to change the appearance of text , uppercase, lowercase, capitalize, inital, inherit, none

line-height property to change the height of each line in a block of text

hover state using the :hover pseudo-class selector

relative only changes flow of that element and not rest of elements, ex: relative with top:10px moves it down 10 
The next option for the CSS position property is absolute, which locks the element in place relative to its parent container. Unlike the relative position, this removes the element from the normal flow of the document, so surrounding items ignore it.
The next layout scheme that CSS offers is the fixed position, which is a type of absolute positioning that locks an element relative to the browser window.

The next positioning tool does not actually use position, but sets the float property of an element. Floating elements are removed from the normal flow of a document and pushed to either the left or right of their containing parent element.

z-index property can specify the order of how elements are stacked on top of one another.

margin:auto to center a block element horizontally.  */

/* background: linear-gradient(gradient_direction, color 1, color 2, color 3, ...);

To change the scale of an element, CSS has the transform property, along with its scale() function.
p:hover {
  transform: scale(2.1);
}
next function of the transform property is skewX(), which skews the selected element along its X (horizontal) axis by a given degree.

@keyframes    animation-name  animation-duration
#anim {
  animation-name: colorful;
  animation-duration: 3s;
}

@keyframes colorful {
  0% {
    background-color: blue;
  }
  100% {
    background-color: yellow;
  }
} */

/* Alt text describes the content of the image and provides a text-alternative for it
<img src="importantLogo.jpeg" alt="Company logo">
One final point, each page should always have one (and only one) h1 element, which is the main subject of your content.

The main element is used to wrap (you guessed it) the main content, and there should be only one per page. It's meant to surround the information that's related to the central topic of your page. It's not meant to include items that repeat across pages, like navigation links or banners.
The main tag also has an embedded landmark feature that assistive technology can use to quickly navigate to the main content. If you've ever seen a "Jump to Main Content" link at the top of a page, using a main tag automatically gives assistive devices that functionality.

article is a sectioning element, and is used to wrap independent, self-contained content. The tag works well with blog entries, forum posts, or news articles.

section is for grouping thematically related content, otherwise use div

header tag. It's used to wrap introductory information or navigation links for its parent tag and works well around content that's repeated at the top on multiple pages.
The header is meant for use in the body tag of your HTML document. This is different than the head element, which contains the page's title, meta information, etc.

The nav element is another HTML5 item with the embedded landmark feature for easy screen reader navigation. This tag is meant to wrap around the main navigation links in your page.

footer element has a built-in landmark feature that allows assistive devices to quickly navigate to it. It's primarily used to contain copyright information or links to related documents that usually sit at the bottom of a page.
 */

/* Media Queries consist of a media type, and if that media type matches the type of device the document is displayed on, the styles are applied. You can have as many selectors and styles inside your media query as you want.

Here's an example of a media query that returns the content when the device's width is less than or equal to 100px:

@media (max-width: 100px) {  }

and the following media query returns the content when the device's height is more than or equal to 350px:

@media (min-height: 350px) { }

Making images responsive with CSS is actually very simple. You just need to add these properties to an image:
img {
  max-width: 100%;
  height: auto;
}
The max-width of 100% will make sure the image is never wider than the container it is in, and the height of auto will make the image keep its original aspect ratio.

The simplest way to make your images properly appear on High-Resolution Displays, such as the MacBook Pros "retina display" is to define their width and height values as only half of what the original file is. Here is an example of an image that is only using half of the original height and width:
<style>
  img { height: 250px; width: 250px; }
</style>


The four different viewport units are:
vw (viewport width): 10vw would be 10% of the viewport's width.
vh (viewport height): 3vh would be 3% of the viewport's height.
vmin (viewport minimum): 70vmin would be 70% of the viewport's smaller dimension (height or width).
vmax (viewport maximum): 100vmax would be 100% of the viewport's bigger dimension (height or width).
 */
